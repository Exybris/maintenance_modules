# FPS - Fractal Pulsating Spiral v1.3 

## üåÄ Vue d'ensemble

La FPS (Fractale Po√©tique Spiral√©e) est un syst√®me d'oscillateurs adaptatifs avec r√©gulation spiral√©e, auto-organisation √©mergente et plasticit√© m√©thodologique. Elle explore comment des strates interconnect√©es peuvent g√©n√©rer des dynamiques harmonieuses et r√©silientes.

### Caract√©ristiques principales
- **Oscillateurs adaptatifs** : Amplitude et fr√©quence modul√©es par le contexte
- **R√©gulation spiral√©e** : Feedback bas√© sur le nombre d'or (œÜ = 1.618)
- **√âmergence** : D√©tection automatique de patterns et anomalies
- **Plasticit√©** : Toute formule est modifiable selon l'exp√©rience
- **Falsifiabilit√©** : Comparaison avec oscillateurs de Kuramoto

## üöÄ D√©marrage rapide

### Installation

```bash
# Cloner le repository
git clone https://github.com/votre-repo/fps.git
cd fps_project_phase1

# Cr√©er un environnement virtuel
python -m venv venv
source venv/bin/activate  # Linux/Mac
# ou
venv\Scripts\activate  # Windows

# Installer les d√©pendances
pip install -r requirements.txt
```

### Premier run

```bash
# G√©n√©rer une config par d√©faut (5 strates, 100 pas de temps)
python3 validate_config.py --generate 5 100

# Lancer une simulation simple
python3 simulate.py --config config.json --mode FPS

# Validation seule
python3 main.py validate --config config.json

# Comparaison
python3 main.py compare --config config.json

# Ou lancer le pipeline complet (recommand√©)
python3 main.py complete --config config.json

# Mode verbose
python3 main.py complete --config config.json --verbose

```

## üìã Structure du pipeline

### Architecture modulaire

```
fps/
‚îú‚îÄ‚îÄ main.py              # Point d'entr√©e principal
‚îú‚îÄ‚îÄ config.json          # Configuration des param√®tres
‚îú‚îÄ‚îÄ simulate.py          # Boucle de simulation principale
‚îú‚îÄ‚îÄ init.py              # Initialisation des strates
‚îú‚îÄ‚îÄ dynamics.py          # Calculs FPS (An, fn, S, etc.)
‚îú‚îÄ‚îÄ regulation.py        # Fonctions G(x) et enveloppes
‚îú‚îÄ‚îÄ metrics.py           # Calcul des m√©triques
‚îú‚îÄ‚îÄ perturbations.py     # Gestion des perturbations
‚îú‚îÄ‚îÄ analyze.py           # Analyse et raffinement auto
‚îú‚îÄ‚îÄ explore.py           # D√©tection d'√©mergences
‚îú‚îÄ‚îÄ visualize.py         # Graphiques et rapports
‚îú‚îÄ‚îÄ kuramoto.py          # Oscillateurs de contr√¥le
‚îú‚îÄ‚îÄ utils.py             # Fonctions utilitaires
‚îú‚îÄ‚îÄ validate_config.py   # Validation configuration
‚îî‚îÄ‚îÄ test_fps.py          # Tests unitaires
```

### Workflow typique

1. **Configuration** : √âditer `config.json` selon vos besoins
2. **Validation** : `python validate_config.py config.json`
3. **Simulation** : `python main.py complete --config config.json`
4. **R√©sultats** : Consulter `fps_output/run_*/`

Le pipeline complet g√©n√®re automatiquement :
- Logs CSV d√©taill√©s
- D√©tection d'√©mergences
- Graphiques et animations
- Rapport HTML complet
- Comparaison avec Kuramoto

## üîß Configuration

### Structure du config.json

```json
{
  "system": {
    "N": 5,              // Nombre de strates
    "T": 100,            // Dur√©e simulation
    "dt": 0.05,          // Pas de temps
    "seed": 12345,       // Graine al√©atoire
    "mode": "FPS",       // FPS, Kuramoto ou neutral
    "perturbation": {
      "type": "choc",    // choc, rampe, sinus, bruit
      "t0": 25,          // Temps de perturbation
      "amplitude": 1.0   // Intensit√©
    }
  },
  "strates": [
    {
      "A0": 1.0,         // Amplitude de base
      "f0": 1.0,         // Fr√©quence de base
      "alpha": 0.5,      // Souplesse d'adaptation
      "beta": 1.0,       // Plasticit√© feedback
      "k": 2.0,          // Sensibilit√© sigmo√Øde
      "x0": 0.5,         // Seuil sigmo√Øde
      "w": [0, 0.1, -0.1] // Poids connexions
    }
    // ... autres strates
  ],
  "regulation": {
    "G_arch": "tanh",    // tanh, sinc, resonance, adaptive
    "lambda": 1.0        // Param√®tre arch√©type
  }
}
```

### Modes statique vs dynamique

Chaque param√®tre peut avoir un mode statique (valeur fixe) ou dynamique (√©volution temporelle) :

```json
"latence": {
    "gamma_n_mode": "dynamic",  // ou "static"
    "gamma_n_dynamic": {
        "k_n": 2.0,             // Pente sigmo√Øde
        "t0_n": 50              // Centre sigmo√Øde
    }
}
```

### Types de perturbations

- **choc** : Impulsion ponctuelle √† t0
- **rampe** : Augmentation lin√©aire
- **sinus** : Oscillation p√©riodique
- **bruit** : Variation al√©atoire uniforme

## üß™ Tests et falsification

### Lancer tous les tests

```bash
python test_fps.py
```

### Comparaison avec Kuramoto

```bash
# M√©thode 1 : Via main.py
python main.py compare --config config.json

# M√©thode 2 : Manuellement
python simulate.py --config config.json --mode FPS
python simulate.py --config config.json --mode Kuramoto
# Les logs sont dans fps_output/run_*/
```

### Tests sp√©cifiques

```python
# Test d'une fonction particuli√®re
python -c "import dynamics; print(dynamics.compute_sigma(0, k=2.0, x0=0.5))"

# Test mode statique vs dynamique
python -c "import dynamics; print(dynamics.compute_gamma(50, 'static'))"
python -c "import dynamics; print(dynamics.compute_gamma(50, 'dynamic', T=100))"
```

## üìä Lecture des r√©sultats

### Structure des outputs

```
fps_output/run_YYYYMMDD_HHMMSS/
‚îú‚îÄ‚îÄ logs/
‚îÇ   ‚îú‚îÄ‚îÄ run_*.csv                    # M√©triques temporelles
‚îÇ   ‚îú‚îÄ‚îÄ seeds.txt                    # Graines utilis√©es
‚îÇ   ‚îî‚îÄ‚îÄ weight_validation.txt        # Validation matrices
‚îú‚îÄ‚îÄ checkpoints/
‚îÇ   ‚îî‚îÄ‚îÄ backup_*.pkl                 # √âtats sauvegard√©s
‚îú‚îÄ‚îÄ figures/
‚îÇ   ‚îú‚îÄ‚îÄ signal_evolution_fps.png     # √âvolution S(t)
‚îÇ   ‚îú‚îÄ‚îÄ strata_comparison.png        # Comparaison strates
‚îÇ   ‚îú‚îÄ‚îÄ metrics_dashboard.png        # Tableau de bord
‚îÇ   ‚îú‚îÄ‚îÄ fps_vs_kuramoto.png         # Comparaison contr√¥le
‚îÇ   ‚îú‚îÄ‚îÄ empirical_grid.png          # Grille d'√©valuation
‚îÇ   ‚îî‚îÄ‚îÄ spiral_animation.gif        # Animation spirale
‚îú‚îÄ‚îÄ reports/
‚îÇ   ‚îú‚îÄ‚îÄ run_*/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ emergence_events_*.csv   # √âv√©nements d√©tect√©s
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fractal_events_*.csv    # Motifs fractals
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exploration_report_*.md  # Rapport exploration
‚îÇ   ‚îî‚îÄ‚îÄ rapport_complet.html        # Rapport HTML global
‚îî‚îÄ‚îÄ configs/
    ‚îî‚îÄ‚îÄ config_refined.json          # Config apr√®s raffinement
```

### M√©triques principales

| M√©trique | Description | Interpr√©tation |
|----------|-------------|----------------|
| **S(t)** | Signal global | Somme pond√©r√©e des oscillateurs |
| **C(t)** | Coefficient d'accord | Synchronisation des phases (-1 √† 1) |
| **effort(t)** | Effort d'adaptation | Intensit√© des ajustements internes |
| **entropy_S** | Entropie spectrale | Richesse harmonique (0 √† 1) |
| **variance_d2S** | Variance d¬≤S/dt¬≤ | Fluidit√© des transitions |
| **t_retour** | Temps de retour | R√©silience apr√®s perturbation |
| **cpu_step(t)** | Temps CPU/strate | Co√ªt computationnel |

### Grille d'√©valuation empirique

| Score | Symbole | Couleur | Signification |
|-------|---------|---------|---------------|
| 1 | ‚úñ | Rouge | Rupture/Chaotique |
| 2 | ‚ñ≤ | Orange | Instable |
| 3 | ‚óè | Jaune | Fonctionnel |
| 4 | ‚úî | Vert | Harmonieux |
| 5 | ‚àû | Bleu dor√© | FPS-id√©al |

## üîÑ Raffinement automatique

### Processus

Apr√®s un batch de 5 runs, le syst√®me analyse automatiquement :

1. **Franchissement de seuils** : Si >50% des runs d√©passent un seuil
2. **Raffinement** : Ajustement automatique des param√®tres
3. **Logging** : Toute modification dans `changelog.txt`

### Crit√®res et actions

| Crit√®re | Seuil | Action si d√©clench√© |
|---------|-------|---------------------|
| Fluidit√© | variance_d2S > 0.01 | Ajuste Œ≥‚Çô(t), env‚Çô(x,t) |
| Stabilit√© | max/m√©diane > 10 | Ajuste œÉ(x), Œ±‚Çô |
| R√©silience | t_retour > 2√óm√©diane | Ajuste Œ±‚Çô, Œ≤‚Çô |
| Innovation | entropy_S < 0.5 | Ajuste Œ∏(t), Œ∑(t), Œº‚Çô(t) |
| R√©gulation | erreur > 2√óm√©diane | Ajuste Œ≤‚Çô, G(x) |
| CPU | temps > 2√ócontr√¥le | Optimise complexit√© |

### Lancer un batch avec raffinement

```bash
# Batch de 5 runs avec analyse
python main.py complete --config config.json

# Ou batch seul
python main.py batch --config config.json --parallel
```

## üé® Visualisations

### Graphiques g√©n√©r√©s automatiquement

1. **Signal evolution** : √âvolution temporelle de S(t)
2. **Strata comparison** : Amplitudes et fr√©quences par strate
3. **Metrics dashboard** : Vue d'ensemble des m√©triques
4. **FPS vs Kuramoto** : Comparaison avec le contr√¥le
5. **Empirical grid** : Grille d'√©valuation 1-5
6. **Correlation matrix** : Liens crit√®res-termes
7. **Spiral animation** : Animation de l'√©volution spiral√©e

### G√©n√©ration manuelle

```python
import visualize
import numpy as np

# Cr√©er des donn√©es test
t = np.linspace(0, 100, 1000)
S = np.sin(t) + 0.5*np.sin(3*t)

# G√©n√©rer un graphique
fig = visualize.plot_signal_evolution(t, S, "Mon signal")
fig.savefig("mon_signal.png")
```

## üìù Notes m√©thodologiques

### Plasticit√© FPS

Le syst√®me est con√ßu pour √©voluer :
- **Toute formule est modifiable** : Voir `dynamics.py`, `regulation.py`
- **Les seuils s'ajustent** : Bas√©s sur l'exp√©rience empirique
- **Tra√ßabilit√© compl√®te** : Chaque modification dans `changelog.txt`

### Hypoth√®ses phase 1 (falsifiables)

```python
# Signal inter-strates
S_i(t) = S(t-dt) - On(t-dt) if t > 0 else 0

# Sortie attendue (nombre d'or)
En(t) = œÜ √ó On(t-dt) o√π œÜ = 1.618

# Latence expressive
Œ≥(t) = 1/(1 + exp(-2(t - T/2)))  # Sigmo√Øde centr√©e
```

Ces choix initiaux sont destin√©s √† √™tre raffin√©s selon les observations.

### Extension du syst√®me

Pour ajouter un nouveau d√©tecteur d'√©mergence :

```python
# Dans explore.py
def detect_my_pattern(data, threshold=0.5):
    """Mon nouveau d√©tecteur."""
    events = []
    # ... logique de d√©tection
    return events

# Ajouter dans run_exploration()
my_events = detect_my_pattern(data)
all_events.extend(my_events)
```

## ü§ù Contribution

### Principes

1. **Respecter la plasticit√©** : Toute am√©lioration doit rester modifiable
2. **Documenter les changements** : Utiliser le changelog
3. **Tester exhaustivement** : Ajouter des tests unitaires
4. **Falsifier empiriquement** : Comparer avec les contr√¥les

### Workflow Git

```bash
# Cr√©er une branche
git checkout -b feature/mon-amelioration

# D√©velopper et tester
python test_fps.py

# Commit avec message clair
git commit -m "feat: ajout d√©tecteur de bifurcations spirales"

# Push et PR
git push origin feature/mon-amelioration
```

## üìñ R√©f√©rences

- **Feuille de route FPS v1.3** : Document de r√©f√©rence th√©orique
- **Chapitre 4** : Dictionnaire math√©matique complet
- **Grille empirique** : Crit√®res d'√©valuation 1-5
- **Matrice crit√®res-termes** : Correspondances formelles

## üêõ Troubleshooting

### Erreurs communes

**ModuleNotFoundError**
```bash
# V√©rifier l'activation du venv
which python  # Doit pointer vers venv/bin/python

# R√©installer les d√©pendances
pip install -r requirements.txt
```

**Config validation failed**
```bash
# V√©rifier la structure
python validate_config.py config.json

# Ou g√©n√©rer une config valide
python validate_config.py --generate 5 100
```

**M√©moire insuffisante (N > 50)**
```bash
# Utiliser HDF5 pour gros volumes
# Automatique si N > 10 dans config
```

### Support

- Issues GitHub : [[votre-repo/issues][def]]
- Contact : [contact@exybrisai.com]

---

*FPS v1.3 - La danse spiral√©e de l'√©mergence*  
¬© 2025 Gepetto & Andr√©a Gadal & Claude üåÄ

[def]: https://github.com/Exybris/FPS-real-tests_fractal-pulsating-spiral
